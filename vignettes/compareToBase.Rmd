---
title: "From base R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{From base R}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 5)
library(dplyr)
```

This vignette aims to compare dplyr functions to base R equivalents to facilitate users transitioning from using base R to dplyr. 

# Single-Table Verbs

| base | dplyr    |
|------|------------|
|   `df[order(x), , drop = FALSE]`   | `arrange(df, x)` |
|   `df[!duplicated(x), , drop = FALSE]`, `unique()`   | `distinct(df, x)`  |
|   `df[x & !is.na(x), , drop = FALSE]`, `subset()`   | `filter(df, x)`  |
|   `df$z <- df$x + df$y`, `transform()`   | `mutate(df, z = x + y)`  |
|   `df$x`    | `pull(df, x)` |
|   N/A   | `rename(df, y = x)` |
|   `df[c("x", "y")]`, `subset()`  | `select(df, x, y)` |
|   `df[grepl(names(df), "^x")]` | `select(df, starts_with("x")` |
|   `mean(df$x)` | `summarise(df, mean(x))` |
|   `df[c(1, 2, 5), , drop = FALSE]` | `slice(df, c(1, 2, 5))` |

# Two-Table Verbs

| base | dplyr    |
|------|------------|
|   `merge(df1, df2)`   | `inner_join(df1, df2)` |
|   `merge(df1, df2, all.x = TRUE)`   | `left_join(df1, df2) `  |
|   ` merge(df1, df2, all.y = TRUE)`   | `right_join(df1, df2)`  |
|   `merge(df1, df2, all = TRUE)`   | `full_join(df1, df2)`  |
|   `df1[df1$x %in% df2$x, , drop = FALSE]`    | `semi_join(df1, df2)` |
|   `df1[!df1$x %in% df2$x, , drop = FALSE]` | `anti_join(df1, df2)` |

Overall the main differences between base R and dplyr are:

1. dplyr provides functions to help us manipulate a data frame via relevant verbs. This style contrasts base R approaches where we more explicitly manipulate the data frame itself. 

2. dplyr banishes the use of `$` to access particular columns of a data frame.

3. Overall, dplyr solutions to data manipulation problems remove nesting of code (e.g. `df[extra_stuff_here, ]`) and is more amenable to the pipe workflow (e.g. `df %>% verb`).

4. Manipulation of data frames by a grouping variable is much more streamlined in dplyr thanks to `group_by()`. 

Now we will walk through each of the functions in the above tables, noting the similarities and differences between base R and dplyr.

These dplyr examples come from the [dplyr documentation](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf) and here, they are contrasted with the analogous base R operation(s).


# Single-Table Verbs

For more information about these single-table verbs see [`vignette("dplyr")`](https://dplyr.tidyverse.org/articles/dplyr.html).

## `arrange()`: Arrange rows by variables

You may want to order a data frame based on the values of one or more columns. In base R you can use the output of `order()` as an index for your data frame. We must remember to use  `drop = F` though to ensure that the result is still a data frame. If our manipulation reduces the data frame to one column and we forget `drop = F`, we will end up with a vector. This can cause problems further into our analysis if we expect a different data type than we actually have. 

```{r}
# base
mtcars[order(mtcars$cyl, mtcars$disp), ,drop = F] %>% head()
```

In dplyr, we simply choose the verb relevant to our goals: `arrange()`.

```{r}
# dplyr
arrange(mtcars, cyl, disp) %>% head()
```


## `distinct()`: Select distinct/unique rows

We may want to streamline our data frame by only including distinct values of a particular variable. Again, we can't forget `drop = F`. 

```{r}
df <- tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)

# base
df[!duplicated(df$x), , drop = F] # whole data frame
unique(df$x) # just see the unique values
```

In both base R and dplyr we can either access the entire data frame or just the column of interest. The corresponding dplyr verb is `distinct()`. 

```{r}
# dplyr
distinct(df, x, .keep_all = TRUE) ## whole data frame
distinct(df, x) ## just see the unique values
```

## `filter()`: Return rows with matching conditions

In base R if we want to narrow our data set based on criteria of interest, `subset()` is used.

```{r}
# base
subset(starwars, species == "Human")
subset(starwars, mass > 1000)
subset(starwars, hair_color == "none" & eye_color == "black")
```

The syntax of dplyr's `filter()` is very similar.

```{r}
# dplyr
filter(starwars, species == "Human")
filter(starwars, mass > 1000)
filter(starwars, hair_color == "none" & eye_color == "black")
```

## `mutate()`: Create or transform variables

We can create new variables as functions of other ones. In base R we directly create a new variable using `$` and assign it a vector of values. We can also use the function `transform()`.

```{r}
# base
mtcars$cyl2 <- mtcars$cyl * 2
mtcars$cyl4 <- mtcars$cyl2 * 2
head(mtcars)

# or
transform(mtcars, cyl3 = cyl*3) %>% head()
```

In dplyr we `mutate()` the data frame but we do not need to use `$` to refer to new or current variables.

```{r}
# dplyr
mtcars %>%
  mutate(
    cyl2 = cyl * 2,
    cyl4 = cyl2 * 2
  ) %>% head()
```

## `pull()`: Pull out a single variable

The dplyr verb `pull()` can replace the base R use of `$`.

```{r}
# base
mtcars[,1]
mtcars$cyl

# dplyr
mtcars %>% pull(1)
mtcars %>% pull(cyl)
```

## `rename()`: Rename variables by name

To rename a variable in base R, we first need to identify which column we want to replace based on `names()`. Then we need to override the name.

```{r}
iris_copy = iris
# base
change_idx <- grep(pattern = "Petal.Length", names(iris))
names(iris)[change_idx] <- "petal_length"
```

In dplyr the `rename()` function takes care of finding the correct column. 

```{r}
# dplyr
rename(iris_copy, petal_length = Petal.Length) %>% head()
```

## `select()`: Select variables by name

To grab certain variables from a data frame in base R, we need to do the work to specify and find the matches.

```{r}
# base
iris[, c("Species", "Petal.Width")] %>% head()
iris[, grepl("^x", names(iris))] %>% head()
```


`select()` has some helper functions that can help us obtain multiple columns based on patterns rather than manually specifying them all. Below we show `starts_with()` but addtional ones include `ends.with()`, `contains()`, `matches()`, `num.range()`, `one_of()`, `everything()`, and `group.cols()`.  

```{r}
# dplyr
select(iris, Species, Petal.Width) %>% head()
select(iris, starts_with("Sepal")) %>% head()
```

## `summarise()`: Reduce multiple values down to a single value

We can find summaries of various columns in our data frame using base R functions

```{r}
# base
mean(mtcars$disp)
nrow(mtcars$disp)
```

In dplyr `summarise()` allows us to make these summaries and keep the answers tidier. We also get access to helpers such as `n()` and `n_distinct()` that count entries.


```{r}
# dplyr
mtcars %>%
  summarise(mean = mean(disp), n = n())
```

## `slice()`: Choose rows by position

We've talked a lot about choosing columns of a data frame, but we can also choose rows of our data frame. In base R we manually subset the data frame using specified indices. 

```{r}
# base
mtcars[25:nrow(mtcars), ]
```

In dplyr `slice()` helps us access particular rows.

```{r}
# dplyr
slice(mtcars, 25:n())
```

# Two-Table Verbs

When we want to merge two data frames (refered to as `x` and `y` in base R's `merge() ` arguments), we have a variety of different ways to bring them together. Various base R `merge()` calls are replaced by a variety of dplyr `join()` functions.

For more information about two-table verbs, see [`vignette("two-table")`](https://dplyr.tidyverse.org/articles/two-table.html).

## `inner_join()`: Join two tables together

If we want only rows that match in both data sets, we use dplyr's `inner_join()`. This drops the rows from the first data frame that do not occur in the second data frame (denoted by base R as `all.x = F`) and the rows from the second data frame that do not occur in the first data frame (denoted by base R as `all.y = F`).

In base R the resulting merged data frame has rows that are sorted in alphabetical order of the common solumns while in dplyr, the order of the first data frame's rows is preserved.

**Q: Which band members also play instruments and what instruments do they play?**

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = F)

# dplyr
band_members %>% inner_join(band_instruments)
```

## `left_join()`: Join two tables together

If we want every row in the first data frame to be preserved in the merged data frame (denoted by base R as `all.x = T`), we use dplyr's `left_join()`. This drops any row in the second data frame that does not match the first data frame (denoted by base R as `all.y = F)`.

**Q: What instrument does every band member play?**

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = F)

# dplyr
band_members %>% left_join(band_instruments)
```

## `right_join()`: Join two tables together

If we want every row in the second data frame to be preserved in the merged data frame (denoted by base R as `all.y = T`), we use dplyr's `right_join()`. This drops any row in the first data frame that does not match the first data frame (denoted by base R as `all.x = F)`.

**Q: Which instruments are played and who are they played by?**

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = T)

# dplyr
band_members %>% right_join(band_instruments)
```

## `full_join()`: Join two tables together

If we want every row in both data frames to be preserved in the merged data frame (denoted by base R as `all.x = T` and `all.y=T` or more concisely, `all = T`), we use dplyr's `full_join()`. This doesn't drop any rows, even if they don't have a match. Matchless rows are filled in with `NA`. 

**Q: What band members and band instruments exist?**

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = T)
merge(band_members, band_instruments, by.x = "name", by.y = "name", all = T) # shortcut

# dplyr
band_members %>% full_join(band_instruments)
```

## `semi_join()`: Join two tables together

If we do not want to add information from another data frame but we care about the rows in one data frame narrowed to those that have a match in another data frame we can use dplyr's `semi_join()`. In base R we have to use `%in%` to help us find the correct rows to access. The `drop = F` option is again needed to ensure we end up with a data frame.

**Q: Which band members play instruments?**

```{r}
# base
band_members[band_members$name %in% band_instruments$name, , drop = F]

# dplyr
band_members %>% semi_join(band_instruments)
```

## `anti_join()`: Join two tables together

If we do not want to add information from another data frame but we care about the rows in one data frame that do not match another data frame we can use dplyr's `anti_join()`. We can use the negation of `%in%` in base R to help us find the correct rows to access, and we need to remember the `drop = F` option.

**Q: Which band members do not play instruments?**

```{r}
# base
band_members[!band_members$name %in% band_instruments$name, , drop = FALSE]

# dplyr
band_members %>% anti_join(band_instruments)
```

# Grouping

One of dplyr's strengths is the ability to manipulate data frames by a grouping variable. To get the average of every column in a dataset by a grouping variable, like species, in base R requires three steps (a `split()`, an `lapply()`, and a `do.call("rbind")`).

```{r}
# base
bySpecies = split(iris, iris$Species) 
class(bySpecies) # returns a list
length(bySpecies) # 3 species
head(bySpecies[[1]]) 
# each element of the list is the subset of the dataset for one species

bySpeciesMeans = lapply(bySpecies, function(x){apply(x[,-ncol(x),],2,mean)})
# get column means for every column but the last (which is the actual species name)

do.call("rbind", bySpeciesMeans)
# rbind each element of the list to make a data frame
```

In dplyr this can be done in one line of code.

```{r}
# dplyr
iris %>% group_by(Species) %>% summarise_all(mean)
```