---
title: "From base R to dplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{From base R to dplyr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4, tibble.print_max = 4)
```

This vignette aims to compare dplyr functions to base R equivalents to facilitate users transitioning from using base R to dplyr, and vice versa. We'll start with a rough overivew, then discuss one table verbs in more detail, then the two table verbs.

```{r setup, message = FALSE}
library(dplyr)
mtcars <- as_tibble(mtcars)
iris <- as_tibble(iris)
```

# Overview

1.  dplyr functions tends to focus on whole data frame operations. This contrasts 
    with base R approaches which tend to more explicitly individual columns within 
    the data frame. 

1.  dplyr relies heavily on the use of "non-standard evaluation" so that you 
    do not need to use `$` to access columns of the "current" data frame. This
    is inspired by the base functions `subset()` and `transform()`.
    
1.  dplyr solutions tend to leverage a vocabulary of single purpose verbs, 
    while base R solution typically tend to use `[` in a variety of ways, 
    depending on the task at hand.
    
    | dplyr | base    |
    |------|------------|
    | `arrange(df, x)`              | `df[order(x), , drop = FALSE]`                   | 
    | `distinct(df, x)`             | `df[!duplicated(x), , drop = FALSE]`, `unique()` | 
    | `filter(df, x)`               | `df[x & !is.na(x), , drop = FALSE]`, `subset()`  | 
    | `mutate(df, z = x + y)`       | `df$z <- df$x + df$y`, `transform()`             | 
    | `pull(df, x)`                 | `df$x`                                           | 
    | `rename(df, y = x)`           | ???                                              | 
    | `relocate(df, y)              | ???                                              | 
    | `select(df, x, y)`            | `df[c("x", "y")]`, `subset()`                    | 
    | `select(df, starts_with("x")` | `df[grepl(names(df), "^x")]`                     | 
    | `summarise(df, mean(x))`      | `mean(df$x)`                                     | 
    | `slice(df, c(1, 2, 5))`       | `df[c(1, 2, 5), , drop = FALSE]`                 | 

1.  The singular focus of dplyr verbs leads naturally to solving more 
    challenging problems by stringing together multiple verbs using the pipe.
    In base R, you'll typically either create variables or override an existing
    variable.

1.  dplyr verbs provide different implementations for different backends.  
    Built-in implementation includes for data frames, tibbles, and "grouped" 
    data frames, and other packages provide implementations for other backends
    like databases, data.tables, and spark.

# Single-table verbs

For more information about two-table verbs, see `vignette("one-table")`.

## `arrange()`: Arrange rows by variables

`dplyr::arrange()` orders the rows of a data frame by the values of one or more variables: 

```{r}
mtcars %>% arrange(cyl, disp)
```

The `desc()` helper allows you to order selected variables in descending order:

```{r}
mtcars %>% arrange(desc(cyl), desc(disp))
```

We can replicate the same result with base R by combining `[` with `order()`:

```{r}
mtcars[order(mtcars$cyl, mtcars$disp), , drop = F]
```

Note the use of `drop = FALSE`. If you forget this, and the input is a data frame with a single column, the output will be a vector, not a data frame. This is a source of subtle bugs.

Base R does not provide a convenient and general way to sort individual variables in descending order. Instead you have two options:

* For numeric variables, you can use `-x`.
* You can request `order()` to sort all variables in descending order

```{r, results = FALSE}
mtcars[order(mtcars$cyl, mtcars$disp, decreasing = T), , drop = F]
mtcars[order(-mtcars$cyl, -mtcars$disp), , drop = F]
```


## `distinct()`: Select distinct/unique rows

`dplyr::distinct()` selects unique rows:

```{r}
df <- tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)

df %>% distinct(x, .keep_all = TRUE) # whole data frame
df %>% distinct(x) # just see the unique values
```

There are two equivalents in base R, depending on whether you want the whole data frame, or just selected variables:

```{r}
df[!duplicated(df$x), , drop = F] # whole data frame
unique(df$x) # just see the unique values
```

Again, you must remeber to use `drop = F`. 

## `filter()`: Return rows with matching conditions

`dplyr::filter()` selects rows where an expression is `TRUE`:

```{r}
starwars %>% filter(species == "Human")
starwars %>% filter(mass > 1000)
starwars %>% filter(hair_color == "none" & eye_color == "black")
```

The closest base equivalent (and the inspiration for `filter()`) is `subset()`:

```{r}
subset(starwars, species == "Human")
subset(starwars, mass > 1000)
subset(starwars, hair_color == "none" & eye_color == "black")
```

You can also use `[` but this requires the use of `which()` to ensure that NA rows are not generated:

```{r}
starwars[which(starwars$species == "human"), , drop = FALSE]
starwars[which(starwars$mass > 1000), , drop = FALSE]
starwars[which(starwars$hair_color == "none" & starwars$eye_color == "black"), , drop = FALSE]
```

## `mutate()`: Create or transform variables

`dplyr::mutate()` creates new variables from existing variables:

```{r}
df %>% mutate(z = x + y, z2 = z ^ 2)
```

The closest base equivalent is `transform()`, but note that it cannot use freshly created variables:

```{r}
transform(df, z = x + y, z2 = (x + y) ^ 2)
```

Alternatively, you can use `$<-`:

```{r}
mtcars$cyl2 <- mtcars$cyl * 2
mtcars$cyl4 <- mtcars$cyl2 * 2
```

When applied to a grouped data frame, `dplyr::mutate()` computes new variable once per group:

```{r}
gf <- tibble(g = c(1, 1, 2, 2), x = c(0.5, 1.5, 2.5, 3.5))
gf %>% 
  group_by(g) %>% 
  mutate(x_mean = mean(x), x_rank = rank(x))
```

To replicate this in base R, you can use `ave()`:

```{r}
transform(gf, 
  x_mean = ave(x, g, FUN = mean), 
  x_rank = ave(x, g, FUN = rank)
)
```

## `pull()`: Pull out a single variable

`dplyr::pull()` extracts a variable either by name or position:

```{r}
mtcars %>% pull(1)
mtcars %>% pull(cyl)
```

This equivalent to either `[[` or `$`:

```{r}
mtcars[[1]]
mtcars$cyl
```

## `relocate()`: Change column order

`dplyr::relocate()` makes it easy to move a set of columns to a new position (by default, the front):

```{r}
# to front
mtcars %>% relocate(gear, carb) 

# to back
mtcars %>% relocate(mpg, cyl, .after = last_col()) 
```

We can replicate this in base R with a little set manipulation:

```{r}
mtcars[union(c("gear", "carb"), names(mtcars))]

to_back <- c("mpg", "cyl")
mtcars[setdiff(names(mtcars), to_back)]
```

Moving columns to somewhere in the middle requires yet more set twiddling.

## `rename()`: Rename variables by name

`dplyr::rename()` allows you to rename variables by name or position:

```{r}
iris %>% rename(sepal_length = Sepal.Length, sepal_width = 2)
```

Renaming variables by position is straight forward in base R:

```{r}
iris2 <- iris
names(iris2)[2] <- "sepal_width"
```

Renaming variables by name requires a bit more work:

```{r}
names(iris2)[which(names(iris2) == "Sepal.Length")] <- "sepal_length"
```

## `select()`: Select variables by name

`dplyr::select()` subsets columns by name, position, or other property:

```{r}
iris %>% select(1:3)
iris %>% select(starts_with("Petal"))
iris %>% select(is.factor)
```

Subsetting variables by position is straightforward in base R:

```{r}
iris[1:3] # single argument selects columns; never drops
iris[1:3, , drop = FALSE]
```

Subsetting by name requires a bit of work with `grep()`:

```{r}
iris[grep("^Petal", names(iris))]
```

And you can use `Filter()` to subset by type:

```{r}
Filter(is.factor, iris)
```

## `summarise()`: Reduce multiple values down to a single value

`dplyr::summarise()` computes one or more summaries for each group:

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarise(mean = mean(disp), n = n())
```

Base R provides a variety of functions, none of which make it particularly easy to get all the results in one data frame.

*   `tapply()` will compute the individual summary values, but reassembling these 
    fragments the fragments back into a complete data frame is challenging:

    ```{r}
    tapply(mtcars$disp, mtcars$cyl, mean)
    tapply(mtcars$disp, mtcars$cyl, length)
    ```
    
    The use of `tapply()` to compute the number of observations in each group
    is mildly idiosyncratic. An alternative would be to use `split()` and 
    `sapply()`:
    
    ```{r}
    sapply(split(mtcars, mtcars$cyl), nrow)
    ```

*   `aggregate()` gives us back a data frame, but you must use the same 
    transformation on every column, so you need to apply it twice:

    ```{r}
    df_mean <- aggregate(mtcars["mpg"], mtcars["cyl"], mean)
    df_mean
    
    df_length <- aggregate(mtcars["mpg"], mtcars["cyl"], length)
    df_length
    ```

    Then `merge()` the results together:

    ```{r}
    names(df_mean)[2] <- "mean"
    names(df_length)[2] <- "n"
    merge(df_mean, df_length, by = "cyl")
    ```
    
    (Note the use of single argument `[` to ensure that both the first and 
    second arguments remain as data frames.)

*   `by()` is very close to what we need, but returns a list of data frames,
    which need to be stitched back together with `rbind()`:

    ```{r}
    mtcars_by <- by(mtcars, mtcars$cyl, function(df) data.frame(mean = mean(df$disp), n = nrow(df)))
    do.call(rbind, mtcars_by)
    ```
    
    (The documentation suggests that the second argument must be a factor or
    a list of factors, but empiricially this doesn't seem to be true.)

## `slice()`: Choose rows by position

`slice()` subsets rows by their numeric location:

```{r}
slice(mtcars, 25:n())
```

This is straightforward to replicate with `[`:

```{r}
mtcars[25:nrow(mtcars), ]
```

# Two-table verbs

When we want to merge two data frames, `x` and `y`), we have a variety of different ways to bring them together. Various base R `merge()` calls are replaced by a variety of dplyr `join()` functions.

| dplyr | base     |
|------|------------|
| `inner_join(df1, df2)` |`merge(df1, df2)`                        | 
| `left_join(df1, df2) ` |`merge(df1, df2, all.x = TRUE)`          | 
| `right_join(df1, df2)` |`merge(df1, df2, all.y = TRUE)`          | 
| `full_join(df1, df2)`  |`merge(df1, df2, all = TRUE)`            | 
| `semi_join(df1, df2)`  |`df1[df1$x %in% df2$x, , drop = FALSE]`  | 
| `anti_join(df1, df2)`  |`df1[!df1$x %in% df2$x, , drop = FALSE]` | 

For more information about two-table verbs, see `vignette("two-table")`.

## Mutating joins: Join two tables together

If we want only rows that match in both data sets, we use dplyr's `inner_join()`. This drops the rows from the first data frame that do not occur in the second data frame (denoted by base R as `all.x = F`) and the rows from the second data frame that do not occur in the first data frame (denoted by base R as `all.y = F`).

In base R the resulting merged data frame has rows that are sorted in alphabetical order of the common solumns while in dplyr, the order of the first data frame's rows is preserved.

Left, right, and full joins drop rows without matches from the second data frame, first data frame, and neither data frame respectively. 

```{r}
## Which band members also play instruments and what instruments do they play?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = F)

# dplyr
band_members %>% inner_join(band_instruments)

## What instrument does every band member play?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = F)

# dplyr
band_members %>% left_join(band_instruments)

## Which instruments are played and who are they played by?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = T)

# dplyr
band_members %>% right_join(band_instruments)

## What band members and band instruments exist?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = T)
merge(band_members, band_instruments, by.x = "name", by.y = "name", all = T) # shortcut

# dplyr
band_members %>% full_join(band_instruments)
```

## `semi_join()`: Join two tables together

If we do not want to add information from another data frame but we care about the rows in one data frame narrowed to those that have a match in another data frame we can use dplyr's `semi_join()`. In base R we have to use `%in%` to help us find the correct rows to access. The `drop = F` option is again needed to ensure we end up with a data frame.


```{r}
## Which band members play instruments?

# base
band_members[band_members$name %in% band_instruments$name, , drop = F]

# dplyr
band_members %>% semi_join(band_instruments)
```

Note that if we want to perform a semi-join based on more than one match criteria in base R, it is non-trivial. We cannot just do two `%in%` statements connected with a logical expression because we need joint matches. However, in dplyr multiple match criteria are easily handled. 

## `anti_join()`: Join two tables together

If we do not want to add information from another data frame but we care about the rows in one data frame that do not match another data frame we can use dplyr's `anti_join()`. We can use the negation of `%in%` in base R to help us find the correct rows to access, and we need to remember the `drop = F` option.

```{r}
## Which band members do not play instruments?

# base
band_members[!band_members$name %in% band_instruments$name, , drop = FALSE]

# dplyr
band_members %>% anti_join(band_instruments)
```

