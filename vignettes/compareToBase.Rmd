---
title: "From base R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{From base R}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 5)
library(dplyr)
```

This vignette aims to compare dplyr functions to base R equivalents to facilitate users transitioning from using base R to dplyr. 

# Single-Table Verbs

| base | dplyr    |
|------|------------|
|   `df[order(x), , drop = FALSE]`   | `arrange(df, x)` |
|   `df[!duplicated(x), , drop = FALSE]`, `unique()`   | `distinct(df, x)`  |
|   `df[x & !is.na(x), , drop = FALSE]`, `subset()`   | `filter(df, x)`  |
|   `df$z <- df$x + df$y`, `transform()`   | `mutate(df, z = x + y)`  |
|   `df$x`    | `pull(df, x)` |
|   N/A   | `rename(df, y = x)` |
|   `df[c("x", "y")]`, `subset()`  | `select(df, x, y)` |
|   `df[grepl(names(df), "^x")]` | `select(df, starts_with("x")` |
|   `mean(df$x)` | `summarise(df, mean(x))` |
|   `df[c(1, 2, 5), , drop = FALSE]` | `slice(df, c(1, 2, 5))` |

# Two-Table Verbs

| base | dplyr    |
|------|------------|
|   `merge(df1, df2)`   | `inner_join(df1, df2)` |
|   `merge(df1, df2, all.x = TRUE)`   | `left_join(df1, df2) `  |
|   ` merge(df1, df2, all.y = TRUE)`   | `right_join(df1, df2)`  |
|   `merge(df1, df2, all = TRUE)`   | `full_join(df1, df2)`  |
|   `df1[df1$x %in% df2$x, , drop = FALSE]`    | `semi_join(df1, df2)` |
|   `df1[!df1$x %in% df2$x, , drop = FALSE]` | `anti_join(df1, df2)` |

Overall the main differences between base R and dplyr are:

1. dplyr provides functions to help you manipulate a data fram via relevant verbs. This style contrasts base R approaches where you more explicitly manipulate the data frame itself. 

2. dplyr banishes the use of `$` to access particular columns of a data frame.

3. Overall, dplyr solutions to data manipulation problems remove nesting of code (e.g. df[extra_stuff_here, ]) and is more amenable to the pipe workflow (e.g. df %>% verb). 

Now we will walk through each of the functions in the above tables, noting the similarities and differences between base R and dplyr.

These dplyr examples come from the [dplyr documentation](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf) and here, they are contrasted with the analogous base R operation(s).


# Single-Table Verbs

## `arrange()`: Arrange rows by variables

You may want to order a data frame based on the values of one or more columns. In base R you can use the output of `order` as an index for your data frame. We must remember to use  `drop = F` though to ensure that the result is still a data frame. If our manipulation reduces the data frame to one column and we forget `drop = F` we will end up with a vector. This can cause problems further into our analysis if we expect a different data type than we actually have. 

```{r}
# base
mtcars[order(mtcars$cyl, mtcars$disp), ,drop = F] %>% head()
```

In dplyr, we simply choose the verb relevant to our goals: `arrange`.

```{r}
# dplyr
arrange(mtcars, cyl, disp) %>% head()
```


## `distinct()`: Select distinct/unique rows

We may want to streamline our data frame by only including distinct values of a particular variable. Again, we can't forget that `drop = F`. 

```{r}
df <- tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)

# base
df[!duplicated(df$x), , drop = F] # whole data frame
unique(df$x) # just see the unique values
```

In both base R and dplyr we can either access the entire data frame or just the column of interest. The corresponding dplyr verb is `distinct'. 

```{r}
# dplyr
distinct(df, x, .keep_all = TRUE) ## whole data frame
distinct(df, x) ## just see the unique values
```

## `filter()`: Return rows with matching conditions

```{r}
# base
subset(starwars, species == "Human")
subset(starwars, mass > 1000)
subset(starwars, hair_color == "none" & eye_color == "black")

# dplyr

filter(starwars, species == "Human")
filter(starwars, mass > 1000)
filter(starwars, hair_color == "none" & eye_color == "black")
```

## `mutate()`: Create or transform variables

```{r}
# base
mtcars$cyl2 <- mtcars$cyl * 2
mtcars$cyl4 <- mtcars$cyl2 * 2

# dplyr
mtcars %>%
  as_tibble() %>%
  mutate(
    cyl2 = cyl * 2,
    cyl4 = cyl2 * 2
  )
```

## `pull()`: Pull out a single variable

```{r}
# base
mtcars[,1]
mtcars$cyl

# dplyr
mtcars %>% pull(1)
mtcars %>% pull(cyl)
```

## `rename()`: Rename variables by name

```{r}
iris_copy = iris
# base
change_idx <- grep(pattern = "Petal.Length", names(iris))
names(iris)[change_idx] <- "petal_length"

# dplyr
rename(iris_copy, petal_length = Petal.Length) %>% head()
```

## `select()`: Select variables by name

```{r}
# base
iris[, c("Species", "Petal.Width")] %>% head()
iris[, grepl("^x", names(iris))] %>% head()

# dplyr
select(iris, Species, Petal.Width) %>% head()
select(iris, starts_with("Sepal")) %>% head()
```

## `summarise()`: Reduce multiple values down to a single value

```{r}
# base
mean(mtcars$disp)
nrow(mtcars$disp)

# dplyr
mtcars %>%
  summarise(mean = mean(disp), n = n())
```

## `slice()`: Choose rows by position

```{r}
# base
mtcars[25:nrow(mtcars), ]

# dplyr
slice(mtcars, 25:n())
```

# Two-Table Verbs

Various `merge` calls are replaced by a variety of `join` functions.

## `inner_join()`: Join two tables together

The rows are by default lexicographically sorted on the common columns, but for sort = FALSE are in an unspecified order.

preserves row order of first data set

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = F)

# dplyr
band_members %>% inner_join(band_instruments)
```

## `left_join()`: Join two tables together

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = F)

# dplyr
band_members %>% left_join(band_instruments)
```

## `right_join()`: Join two tables together

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = T)

# dplyr
band_members %>% right_join(band_instruments)
```

## `full_join()`: Join two tables together

```{r}
# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = T)

# dplyr
band_members %>% full_join(band_instruments)
```

## `semi_join()`: Join two tables together

return all rows from `x` where there are matching values in `y`

only returns columns from `x`

```{r}
# base
band_members[band_members$name %in% band_instruments$name, , drop = FALSE]

# dplyr
band_members %>% semi_join(band_instruments)
```

## `anti_join()`: Join two tables together

return all rows from `x` where are not matching values in `y`

only returns columsn from `x`

```{r}
# base
band_members[!band_members$name %in% band_instruments$name, , drop = FALSE]

# dplyr
band_members %>% anti_join(band_instruments)
```

